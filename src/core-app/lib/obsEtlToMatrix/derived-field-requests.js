// src/core-app/lib/obsEtlToMatrix/derived/derived-field-requests.js
//------------------------------------------------------------------------------

import { PURPOSE_TYPES } from '../sum-types';

/**
 *
 * The inputs are limited by the fields included in the group.
 *
 * Call the config when we generate the request.
 * The config is all that is required by the backend.  Everything else is to
 * specify how to recruit user input when making a request for the derived field.
 *
 */
export const derivedFields = {
  meta: {
    description:
      'Will apply the function to each of the fields generated by this part of the request.',
    instructions:
      'Apply the selected function to each in the group of fields generated by this request.',
  },
  decile: {
    id: 'decile',
    menuItem: 'decile',
    config: configDecileRequest, // Fn
    fmapOrApply: 'fmap',
    arity: 1,
    userInput: {
      metric: { name: 'metric', type: 'fieldName', displayType: 'none' },
    },
    meta: {
      description: 'Qualifies each subject based on a ranked decile (10 highest)',
      instructions: 'Choose a measurement and time period.',
    },
  },
  firstEvent: {
    id: 'firstEvent',
    menuItem: 'first-event',
    config: configFirstEvent,
    fmapOrApply: 'fmap',
    arity: 1,
    userInput: {
      event: { name: 'event-timing', type: 'fieldName', displayType: 'none' },
    },
    meta: {
      description: 'Report the date(indexed) for the first occurence of the event',
      instructions: 'Place a single measurement in the group.',
    },
  },
  lastEvent: {
    id: 'lastEvent',
    menuItem: 'last-event',
    config: configLastEvent,
    fmapOrApply: 'fmap',
    arity: 1,
    userInput: {
      event: { name: 'event-timing', type: 'fieldName', displayType: 'none' },
    },
    meta: {
      description: 'Report the date(indexed) for the last occurence of the event',
      instructions: 'Place a single measurement in the group.',
    },
  },
  ratio: {
    id: 'ratio',
    menuItem: 'ratio',
    config: configRatioRequest,
    fmapOrApply: 'apply',
    arity: 2,
    userInput: {
      numerator: { name: 'numerator', type: 'fieldName', displayType: 'none' },
      denominator: {
        name: 'denominator',
        type: 'fieldName',
        displayType: 'none',
      },
    },
    meta: {
      description: 'Compute the ratio of two fields (or sets of fields)',
      instructions: 'Place two measurements in the group; the numerator at the top.',
    },
  },
  ratioWithUniverse: {
    id: 'ratioWithUniverse',
    menuItem: 'value/univ.',
    config: configRatioWithUniverse,
    fmapOrApply: 'apply',
    arity: 2,
    userInput: {
      numerator: { name: 'numerator', type: 'fieldName', displayType: 'none' },
      denominator: {
        name: 'denominator',
        type: 'fieldName',
        displayType: 'none',
      },
    },
    meta: {
      description:
        'Compute the ratio of two fields (or sets of fields); the second field is the sum of the universe',
      instructions:
        'Place two matching measurements in the group; the numerator at the top.',
    },
    validations: (numerator, denominator) => {
      if (numerator !== denominator) {
        return [
          {
            key: 'notTheSameMetric',
            level: 'WARNING',
            message: `The subject and universe ratio is using different values`,
            fix: 'Make sure the fields in the numerator match those of the denominator',
            doc: 'This is a normalizing ratio: subject values / universe; to normalize with apples to apples, they should be the same',
          },
        ];
      }
      return [];
    },
  },
  propensity: {
    id: 'propensity',
    menuItem: 'propensity',
    config: configIdentityFn,
    fmapOrApply: 'apply', // arity to match field count in group
    arity: undefined,
    userInput: {
      binaryTag: {
        name: 'binaryTag',
        display: 'binary tag',
        type: 'fieldName',
        displayType: 'menu',
      },
      factors: {
        name: 'factors',
        type: 'listOfFieldNames',
        displayType: 'none',
      },
      binCount: {
        name: 'binCount',
        display: 'bin count',
        type: 'integer',
        displayType: 'input',
      },
    },
    meta: {
      description:
        'Determines likelyhood of inclusion depending on factors (qualities) included in the computation.',
      instructions:
        'Add any number of factors to the group.  Place the binary factor at the top.',
    },
  },
  identity: {
    id: 'identity',
    menuItem: 'identity fn',
    config: configIdentityFn,
    fmapOrApply: 'fmap',
    arity: 1,
    userInput: {
      metric: { name: 'metric', type: 'fieldName', displayType: 'none' },
    },
    meta: {
      description: 'Testing placeholder function',
      instructions: 'Identify fn - nothing to do',
    },
  },
};

/**
 * Converts a node -> array using the node.data.cache that can then
 * be mapped over using a function
 *
 *     fieldName -> derived field configuration
 *
 */
export const fmapPreProcessCache = (node) => [
  ...new Set(node.data.cache.flatMap((x) => x)),
];

//------------------------------------------------------------------------------
// function/service types
// Note: the subject product_A + subject product_B = product_AB is a
// reduction and thus input (not a transformation).
//
// const serviceTypes = {
//
// normalization (something that could become the dependent variable):
// share: measurement -> measurement, subject / universe value
//
// natural transformation:
// propensity: qualities, bins -> quality, subject / universe
// decile: measurement, bins -> quality, subject / universe
// binning: measurement, bins -> quality, subject / universe
//
// };
//------------------------------------------------------------------------------
//
/**
 * TODO:  Specify an interface definition
 * see matrix-derived-field.md in tnc-py
 *
 * configuration read-in by tnc-py: tnc.data.matrix.py (def go)
 *
 *
 * {
 *  "derived": [
 *    {
 *      "fieldName": "NewFieldName",
 *      "inputs": [
 *        {
 *          "source": "MatrixField" | "EtlUnit",
 *          "identifier": "ExistingFieldName" | "EtlUnitName",
 *          "dataType": "number" | "date" | "string" | "boolean"
 *        }
 *        // ... (more inputs if needed)
 *      ],
 *      "function": {
 *        "name": "FunctionName",
 *        "output": { "type": "number" | "date" | "string" | "boolean" },
 *        "config": {
 *          // ... (function-specific configuration parameters)
 *        }
 *      }
 *    }
 *    // ...
 *  ]
 * }
 *
 *
 * @function
 * @param {string} fieldName what to name the field
 * @param {string} metric the source for the decile analysis
 * @return {Object} with props fieldName and config
 */
function configDecileRequest(input) {
  const { metric, fieldName: fieldName_ = null } = input;

  const fieldName = fieldName_ || `${metric}.derivedField::decile`;

  return {
    fieldName,
    config: {
      fieldName,
      inputs: [
        {
          sourceType: 'MatrixField', // or EtlUnit
          identifier: metric,
          dataType: 'number',
          scope: 'subject',
        },
      ],
      function: {
        name: 'decile',
        output: { type: 'number' },
        config: {
          levels: 10,
        },
      },
    },
  };
}
function configFirstEvent(input) {
  const { metric, fieldName: fieldName_ = null, sources = [] } = input;

  const fieldName = fieldName_ || `${metric}.derivedField::firstEvent`;

  return {
    fieldName,
    config: {
      fieldName,
      inputs: [
        {
          sourceType: 'EtlUnit::measurement',
          identifier: sources[0],
          dataType: 'date',
          purpose: PURPOSE_TYPES.MSPAN,
          scope: 'subject',
        },
      ],
      function: {
        name: 'first_event',
        output: { type: 'date_idx' },
        config: {
          date_type: 'indexed',
        },
      },
    },
  };
}
function configLastEvent(input) {
  const { metric, fieldName: fieldName_ = null, sources = [] } = input;

  const fieldName = fieldName_ || `${metric}.derivedField::lastEvent`;

  return {
    fieldName,
    config: {
      fieldName,
      inputs: [
        {
          sourceType: 'EtlUnit::measurement',
          identifier: sources[0],
          dataType: 'date',
          purpose: PURPOSE_TYPES.MSPAN,
          scope: 'subject',
        },
      ],
      function: {
        name: 'last_event',
        output: { type: 'date_idx' },
        config: {
          date_type: 'indexed',
        },
      },
    },
  };
}
//------------------------------------------------------------------------------
//
/**
 * Spec set by the backend.
 * Returns a derived field request
 *
 * @function
 * @param {string} fieldName what to name the field
 * @param {string} numerator
 * @param {string} denominator
 * @return {Object} with props fieldName and config
 */
function configRatioRequest(input) {
  const [numerator, denominator, fieldName_ = null] = input;

  const fieldName = fieldName_ || `${numerator}-div-${denominator}.derivedField::ratio`;

  return {
    fieldName,
    config: {
      fieldName,
      inputs: [
        {
          name: 'numerator',
          identifier: numerator,
          sourceType: 'MatrixField',
          dataType: 'number',
          scope: 'subject',
        },
        {
          name: 'denominator',
          identifier: denominator,
          sourceType: 'MatrixField',
          dataType: 'number',
          scope: 'subject',
        },
      ],
      function: {
        name: 'ratio',
        output: { type: 'number' },
        config: {
          divZeroValue: 0,
        },
      },
    },
  };
}
//------------------------------------------------------------------------------
//
/**
 * Spec set by the backend.
 * Returns a derived field request
 *
 * @function
 * @param {string} fieldName what to name the field
 * @param {string} numerator
 * @param {string} denominator
 * @return {Object} with props fieldName and config
 */
function configRatioWithUniverse(input) {
  const [numerator, denominator, fieldName = null] = input;

  return {
    fieldName:
      fieldName || `${numerator}-div-${denominator}.derivedField::ratioWithUniv`,
    config: {
      name: fieldName || `${input}.derivedField::ratioWithUniv`,
      inputs: {
        numerator,
        denominator,
      },
      sources: [],
      function: {
        // name to match py class name prop
        name: 'ratioWithUniverse',
        input: [
          { type: 'number', scope: 'subject' },
          { type: 'number', scope: 'universe' },
        ],
        output: { type: 'number' },
        config: {
          divZeroValue: 0, // consistent when measurement = 0 when null
        },
      },
    },
  };
}

/**
 * spec is set by the backend
 *
 * @param {string} etlUnitFieldName
 * @return {Object} with props fieldName and config
 */
function configIdentityFn(input) {
  const { metric = input, fieldName = null } = input;

  return {
    fieldName: fieldName || `${input}.derivedField::identity`,
    config: {
      name: fieldName || `${input}.derivedField::identity`,
      inputs: {
        metric,
      },
      sources: [],
      function: {
        input: [{ type: 'number', scope: 'subject' }],
        output: { type: 'number' },
        name: 'identity',
      },
    },
  };
}
