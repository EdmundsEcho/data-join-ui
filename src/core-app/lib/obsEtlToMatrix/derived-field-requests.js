//------------------------------------------------------------------------------
/**
 * database
 *
 * The inputs are limited by the fields included in the group.
 *
 * Call the config when we generate the request.
 *
 * Provides a unified ref over two phases of the configuration.
 * üëâ user-input support
 * üëâ request configuration support
 *
 */
export const derivedFields = {
  meta: {
    description:
      'Will apply the function to each of the fields generated by this part of the request.',
    instructions:
      'Apply the selected function to each in the group of fields generated by this request.',
  },
  decile: {
    id: 'decile',
    menuItem: 'decile',
    config: configDecileRequest,
    fmapOrApply: 'fmap',
    arity: 1,
    userInput: {
      metric: { name: 'metric', type: 'fieldName', displayType: 'none' },
    },
    meta: {
      description:
        'Qualifies each subject based on a ranked decile (10 highest)',
      instructions: 'Choose a measurement and time period.',
    },
  },
  ratio: {
    id: 'ratio',
    menuItem: 'ratio',
    config: configRatioRequest,
    fmapOrApply: 'apply',
    arity: 2,
    userInput: {
      numerator: { name: 'numerator', type: 'fieldName', displayType: 'none' },
      denominator: {
        name: 'denominator',
        type: 'fieldName',
        displayType: 'none',
      },
    },
    meta: {
      description: 'Compute the ratio of two fields (or sets of fields)',
      instructions:
        'Place two measurements in the group; the numerator at the top.',
    },
  },
  ratioWithUniverse: {
    id: 'ratioWithUniverse',
    menuItem: 'value/univ.',
    config: configRatioWithUniverse,
    fmapOrApply: 'apply',
    arity: 2,
    userInput: {
      numerator: { name: 'numerator', type: 'fieldName', displayType: 'none' },
      denominator: {
        name: 'denominator',
        type: 'fieldName',
        displayType: 'none',
      },
    },
    meta: {
      description:
        'Compute the ratio of two fields (or sets of fields); the second field is the sum of the universe',
      instructions:
        'Place two matching measurements in the group; the numerator at the top.',
    },
    validations: (numerator, denominator) => {
      if (numerator !== denominator) {
        return [
          {
            key: 'notTheSameMetric',
            level: 'WARNING',
            message: `The subject and universe ratio is using different values`,
            fix:
              'Make sure the fields in the numerator match those of the denominator',
            doc:
              'This is a normalizing ratio: subject values / universe; to normalize with apples to apples, they should be the same',
          },
        ];
      }
      return [];
    },
  },
  propensity: {
    id: 'propensity',
    menuItem: 'propensity',
    config: configIdentityFn,
    fmapOrApply: 'apply', // arity to match field count in group
    arity: undefined,
    userInput: {
      binaryTag: {
        name: 'binaryTag',
        display: 'binary tag',
        type: 'fieldName',
        displayType: 'menu',
      },
      factors: {
        name: 'factors',
        type: 'listOfFieldNames',
        displayType: 'none',
      },
      binCount: {
        name: 'binCount',
        display: 'bin count',
        type: 'integer',
        displayType: 'input',
      },
    },
    meta: {
      description:
        'Determines likelyhood of inclusion depending on factors (qualities) included in the computation.',
      instructions:
        'Add any number of factors to the group.  Place the binary factor at the top.',
    },
  },
  identity: {
    id: 'identity',
    menuItem: 'identity fn',
    config: configIdentityFn,
    fmapOrApply: 'fmap',
    arity: 1,
    userInput: {
      metric: { name: 'metric', type: 'fieldName', displayType: 'none' },
    },
    meta: {
      description: 'Testing placeholder function',
      instructions: 'Identify fn - nothing to do',
    },
  },
};

export const fmapPreProcessCache = (node) => [
  ...new Set(node.data.cache.flatMap((x) => x)),
];

//------------------------------------------------------------------------------
// function/service types
// Note: the subject product_A + subject product_B = product_AB is a
// reduction and thus input (not a transformation).
//
// const serviceTypes = {
//
// normalization (something that could become the dependent variable):
// share: measurement -> measurement, subject / universe value
//
// natural transformation:
// propensity: qualities, bins -> quality, subject / universe
// decile: measurement, bins -> quality, subject / universe
// binning: measurement, bins -> quality, subject / universe
//
// };
//------------------------------------------------------------------------------
//
/**
 * ‚ö†Ô∏è  This needs a formal interface definition
 *
 * As of Aug 14, 2021:
 *
 * configuration read-in by tnc-py: tnc.data.matrix.py (def go)
 * requires:
 *
 *    fieldName
 *     config
 *       name,
 *       inputs,
 *       function
 *          name
 *
 * Spec set by the backend.
 * Returns a derived field request
 *
 * @function
 * @param {string} fieldName what to name the field
 * @param {string} metric the source for the decile analysis
 * @return {Object} with props fieldName and config
 */
function configDecileRequest(input) {
  const { metric = input, fieldName = null } = input;

  return {
    fieldName: fieldName || `${input}.derivedField::decile`,
    config: {
      name: fieldName || `${input}.derivedField::decile`,
      inputs: {
        metric,
      },
      function: {
        name: 'decile',
        input: [{ type: 'number', scope: 'subject' }],
        output: { type: 'number' },
        config: {
          levels: 10,
        },
      },
    },
  };
}
//------------------------------------------------------------------------------
//
/**
 * Spec set by the backend.
 * Returns a derived field request
 *
 * @function
 * @param {string} fieldName what to name the field
 * @param {string} numerator
 * @param {string} denominator
 * @return {Object} with props fieldName and config
 */
function configRatioRequest(input) {
  const [numerator, denominator, fieldName = null] = input;

  return {
    fieldName:
      fieldName || `${numerator}-div-${denominator}.derivedField::ratio`,
    config: {
      // requires name, inputs, function: {name}
      name: fieldName || `${input}.derivedField::ratio`,
      inputs: {
        numerator,
        denominator,
      },
      function: {
        name: 'ratio',
        input: [
          { type: 'number', scope: 'subject' },
          { type: 'number', scope: 'subject' },
        ],
        output: { type: 'number' },
        config: {
          divZeroValue: 0, // consistent when measurement = 0 when null
        },
      },
    },
  };
}
//------------------------------------------------------------------------------
//
/**
 * Spec set by the backend.
 * Returns a derived field request
 *
 * @function
 * @param {string} fieldName what to name the field
 * @param {string} numerator
 * @param {string} denominator
 * @return {Object} with props fieldName and config
 */
function configRatioWithUniverse(input) {
  const [numerator, denominator, fieldName = null] = input;

  return {
    fieldName:
      fieldName ||
      `${numerator}-div-${denominator}.derivedField::ratioWithUniv`,
    config: {
      name: fieldName || `${input}.derivedField::ratioWithUniv`,
      inputs: {
        numerator,
        denominator,
      },
      function: {
        // name to match py class name prop
        name: 'ratioWithUniverse',
        input: [
          { type: 'number', scope: 'subject' },
          { type: 'number', scope: 'universe' },
        ],
        output: { type: 'number' },
        config: {
          divZeroValue: 0, // consistent when measurement = 0 when null
        },
      },
    },
  };
}

/**
 * spec is set by the backend
 *
 * @param {string} etlUnitFieldName
 * @return {Object} with props fieldName and config
 */
function configIdentityFn(input) {
  const { metric = input, fieldName = null } = input;

  return {
    fieldName: fieldName || `${input}.derivedField::identity`,
    config: {
      name: fieldName || `${input}.derivedField::identity`,
      inputs: {
        metric,
      },
      function: {
        input: [{ type: 'number', scope: 'subject' }],
        output: { type: 'number' },
        name: 'identity',
      },
    },
  };
}
